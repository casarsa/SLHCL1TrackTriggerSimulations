diff --git a/IOMC/ParticleGuns/interface/FlatRandomOneOverPtChargeGunProducer.h b/IOMC/ParticleGuns/interface/FlatRandomOneOverPtChargeGunProducer.h
new file mode 100644
index 0000000..66a7dda
--- /dev/null
+++ b/IOMC/ParticleGuns/interface/FlatRandomOneOverPtChargeGunProducer.h
@@ -0,0 +1,37 @@
+#ifndef FlatRandomOneOverPtChargeGunProducer_H
+#define FlatRandomOneOverPtChargeGunProducer_H
+
+/** \class FlatRandomOneOverPtChargeGunProducer
+ *
+ * Generates single particle gun flat in (1/pt) in HepMC format
+ **************************************************************/
+
+#include "IOMC/ParticleGuns/interface/BaseFlatGunProducer.h"
+
+namespace edm
+{
+  
+  class FlatRandomOneOverPtChargeGunProducer : public BaseFlatGunProducer
+  {
+  
+  public:
+    FlatRandomOneOverPtChargeGunProducer(const ParameterSet & pset);
+    virtual ~FlatRandomOneOverPtChargeGunProducer();
+   
+    virtual void produce(Event & e, const EventSetup& es) override;
+
+  private:
+    
+    // data members
+    
+    double            fMinOneOverPt   ;
+    double            fMaxOneOverPt   ;
+    double            fXFlatSpread   ;
+    double            fYFlatSpread   ;
+    double            fZFlatSpread   ;
+    bool              fReallyFlat    ;
+
+  };
+} 
+
+#endif
diff --git a/IOMC/ParticleGuns/interface/FlatRandomPtChargeGunProducer.h b/IOMC/ParticleGuns/interface/FlatRandomPtChargeGunProducer.h
new file mode 100644
index 0000000..6b9a84e
--- /dev/null
+++ b/IOMC/ParticleGuns/interface/FlatRandomPtChargeGunProducer.h
@@ -0,0 +1,37 @@
+#ifndef FlatRandomPtChargeGunProducer_H
+#define FlatRandomPtChargeGunProducer_H
+
+/** \class FlatRandomPtChargeGunProducer
+ *
+ * Generates single particle gun in HepMC format
+ * Julia Yarba 12/2005 
+ ***************************************/
+
+#include "IOMC/ParticleGuns/interface/BaseFlatGunProducer.h"
+
+namespace edm
+{
+  
+  class FlatRandomPtChargeGunProducer : public BaseFlatGunProducer
+  {
+  
+  public:
+    FlatRandomPtChargeGunProducer(const ParameterSet & pset);
+    virtual ~FlatRandomPtChargeGunProducer();
+   
+    virtual void produce(Event & e, const EventSetup& es) override;
+
+  private:
+    
+    // data members
+    
+    double            fMinPt   ;
+    double            fMaxPt   ;
+    double            fXFlatSpread   ;
+    double            fYFlatSpread   ;
+    double            fZFlatSpread   ;
+
+  };
+} 
+
+#endif
diff --git a/IOMC/ParticleGuns/src/FlatRandomOneOverPtChargeGunProducer.cc b/IOMC/ParticleGuns/src/FlatRandomOneOverPtChargeGunProducer.cc
new file mode 100644
index 0000000..db3d87a
--- /dev/null
+++ b/IOMC/ParticleGuns/src/FlatRandomOneOverPtChargeGunProducer.cc
@@ -0,0 +1,128 @@
+#include <ostream>
+
+#include "IOMC/ParticleGuns/interface/FlatRandomOneOverPtChargeGunProducer.h"
+
+#include "SimDataFormats/GeneratorProducts/interface/HepMCProduct.h"
+#include "SimDataFormats/GeneratorProducts/interface/GenEventInfoProduct.h"
+
+#include "FWCore/Framework/interface/Event.h"
+#include "FWCore/ParameterSet/interface/ParameterSet.h"
+#include "FWCore/MessageLogger/interface/MessageLogger.h"
+
+#include "CLHEP/Units/GlobalSystemOfUnits.h"
+using namespace edm;
+
+FlatRandomOneOverPtChargeGunProducer::FlatRandomOneOverPtChargeGunProducer(const edm::ParameterSet& pset) : 
+  BaseFlatGunProducer(pset) {
+
+
+  edm::ParameterSet defpset ;
+  edm::ParameterSet pgun_params = 
+    pset.getParameter<ParameterSet>("PGunParameters") ;
+  
+  fMinOneOverPt = pgun_params.getParameter<double>("MinOneOverPt");
+  fMaxOneOverPt = pgun_params.getParameter<double>("MaxOneOverPt");
+  fXFlatSpread  = pgun_params.exists("XFlatSpread") ? pgun_params.getParameter<double>("XFlatSpread") : 0.;
+  fYFlatSpread  = pgun_params.exists("YFlatSpread") ? pgun_params.getParameter<double>("YFlatSpread") : 0.;
+  fZFlatSpread  = pgun_params.exists("ZFlatSpread") ? pgun_params.getParameter<double>("ZFlatSpread") : 0.;
+  fReallyFlat   = pgun_params.exists("ReallyFlat")  ? pgun_params.getParameter<bool>  ("ReallyFlat")  : false;
+  
+  produces<HepMCProduct>();
+  produces<GenEventInfoProduct>();
+
+  edm::LogInfo("ParticleGun") << "FlatRandomOneOverPtChargeGunProducer: initialized with minimum and maximum 1/pt " << fMinOneOverPt << ":" << fMaxOneOverPt;
+}
+
+FlatRandomOneOverPtChargeGunProducer::~FlatRandomOneOverPtChargeGunProducer() {
+  // no need to cleanup GenEvent memory - done in HepMCProduct
+}
+
+void FlatRandomOneOverPtChargeGunProducer::produce(Event &e, const EventSetup& es) {
+
+  LogDebug("ParticleGun") << " FlatRandomOneOverPtChargeGunProducer : Begin New Event Generation"; 
+
+  // event loop (well, another step in it...)
+          
+  // no need to clean up GenEvent memory - done in HepMCProduct
+  // 
+   
+  // here re-create fEvt (memory)
+  //
+  fEvt = new HepMC::GenEvent() ;
+   
+  // now actualy, cook up the event from PDGTable and gun parameters
+  //
+  // 1st, primary vertex
+  //
+  double xpos = fXFlatSpread > 0. ? fRandomGenerator->fire(-fXFlatSpread,fXFlatSpread) : 0.;
+  double ypos = fYFlatSpread > 0. ? fRandomGenerator->fire(-fYFlatSpread,fYFlatSpread) : 0.;
+  double zpos = fZFlatSpread > 0. ? fRandomGenerator->fire(-fZFlatSpread,fZFlatSpread) : 0.;
+  HepMC::GenVertex* Vtx = new HepMC::GenVertex(HepMC::FourVector(xpos,ypos,zpos));
+
+  // loop over particles
+  //
+  int barcode = 1 ;
+  for (unsigned int ip=0; ip<fPartIDs.size(); ++ip) {
+
+    double xx     = fRandomGenerator->fire(0.0,1.0);
+    double pt     = std::exp((1.-xx)*std::log(fMinOneOverPt)+
+			     xx*std::log(fMaxOneOverPt)) ;
+    if (fReallyFlat)
+           pt     = fMinOneOverPt + xx * (fMaxOneOverPt - fMinOneOverPt);
+    double eta    = fRandomGenerator->fire(fMinEta, fMaxEta) ;
+    double phi    = fRandomGenerator->fire(fMinPhi, fMaxPhi) ;
+    double charge = fRandomGenerator->fire(0, 1) ;
+    if (pt != 0) pt = 1./pt;
+    int PartID = fPartIDs[ip] ;
+    if ( charge < 0.5 )  PartID = -PartID;
+    const HepPDT::ParticleData* 
+      PData = fPDGTable->particle(HepPDT::ParticleID(abs(PartID))) ;
+    double mass   = PData->mass().value() ;
+    double theta  = 2.*atan(exp(-eta)) ;
+    double mom    = pt/sin(theta) ;
+    double px     = pt*cos(phi) ;
+    double py     = pt*sin(phi) ;
+    double pz     = mom*cos(theta) ;
+    double energy2= mom*mom + mass*mass ;
+    double energy = sqrt(energy2) ; 
+    HepMC::FourVector p(px,py,pz,energy) ;
+    HepMC::GenParticle* Part = new HepMC::GenParticle(p,PartID,1);
+    Part->suggest_barcode( barcode ) ;
+    barcode++ ;
+    Vtx->add_particle_out(Part);
+    LogDebug("ParticleGun") << "FlatRandomOneOverPtChargeGunProducer: Event generated with pt:eta:phi " << pt << " " << eta << " " << phi << " (" << theta/CLHEP::deg << ":" << phi/CLHEP::deg << ")";
+
+    if ( fAddAntiParticle ) {
+      HepMC::FourVector ap(-px,-py,-pz,energy) ;
+      int APartID = -PartID ;
+      if ( PartID == 22 || PartID == 23 ) {
+	APartID = PartID ;
+      }	  
+      HepMC::GenParticle* APart = new HepMC::GenParticle(ap,APartID,1);
+      APart->suggest_barcode( barcode ) ;
+      barcode++ ;
+      Vtx->add_particle_out(APart) ;
+    }
+
+  }
+
+  fEvt->add_vertex(Vtx) ;
+  fEvt->set_event_number(e.id().event()) ;
+  fEvt->set_signal_process_id(20) ; 
+        
+  if ( fVerbosity > 0 ) {
+    fEvt->print() ;  
+  }
+
+  std::auto_ptr<HepMCProduct> BProduct(new HepMCProduct()) ;
+  BProduct->addHepMCData( fEvt );
+  e.put(BProduct);
+
+  std::auto_ptr<GenEventInfoProduct> genEventInfo(new GenEventInfoProduct(fEvt));
+  e.put(genEventInfo);
+    
+  LogDebug("ParticleGun") << " FlatRandomOneOverPtChargeGunProducer : Event Generation Done ";
+}
+
+#include "FWCore/Framework/interface/MakerMacros.h"
+DEFINE_FWK_MODULE(FlatRandomOneOverPtChargeGunProducer);
diff --git a/IOMC/ParticleGuns/src/FlatRandomPtChargeGunProducer.cc b/IOMC/ParticleGuns/src/FlatRandomPtChargeGunProducer.cc
new file mode 100644
index 0000000..7655b94
--- /dev/null
+++ b/IOMC/ParticleGuns/src/FlatRandomPtChargeGunProducer.cc
@@ -0,0 +1,140 @@
+/*
+ *  $Date: 2009/02/19 21:52:40 $
+ *  $Revision: 1.4 $
+ *  \author Julia Yarba
+ */
+
+#include <ostream>
+
+#include "IOMC/ParticleGuns/interface/FlatRandomPtChargeGunProducer.h"
+
+#include "SimDataFormats/GeneratorProducts/interface/HepMCProduct.h"
+#include "SimDataFormats/GeneratorProducts/interface/GenEventInfoProduct.h"
+
+#include "FWCore/Framework/interface/Event.h"
+#include "FWCore/ParameterSet/interface/ParameterSet.h"
+
+
+using namespace edm;
+using namespace std;
+
+FlatRandomPtChargeGunProducer::FlatRandomPtChargeGunProducer(const ParameterSet& pset) : 
+   BaseFlatGunProducer(pset)
+{
+
+
+   ParameterSet defpset ;
+   ParameterSet pgun_params = 
+      pset.getParameter<ParameterSet>("PGunParameters") ;
+  
+   fMinPt = pgun_params.getParameter<double>("MinPt");
+   fMaxPt = pgun_params.getParameter<double>("MaxPt");
+   fXFlatSpread  = pgun_params.exists("XFlatSpread") ? pgun_params.getParameter<double>("XFlatSpread") : 0.;
+   fYFlatSpread  = pgun_params.exists("YFlatSpread") ? pgun_params.getParameter<double>("YFlatSpread") : 0.;
+   fZFlatSpread  = pgun_params.exists("ZFlatSpread") ? pgun_params.getParameter<double>("ZFlatSpread") : 0.;
+  
+  produces<HepMCProduct>();
+  produces<GenEventInfoProduct>();
+}
+
+FlatRandomPtChargeGunProducer::~FlatRandomPtChargeGunProducer()
+{
+   // no need to cleanup GenEvent memory - done in HepMCProduct
+}
+
+void FlatRandomPtChargeGunProducer::produce(Event &e, const EventSetup& es) 
+{
+
+   if ( fVerbosity > 0 )
+   {
+      cout << " FlatRandomPtChargeGunProducer : Begin New Event Generation" << endl ; 
+   }
+   // event loop (well, another step in it...)
+          
+   // no need to clean up GenEvent memory - done in HepMCProduct
+   // 
+   
+   // here re-create fEvt (memory)
+   //
+   fEvt = new HepMC::GenEvent() ;
+   
+   // now actualy, cook up the event from PDGTable and gun parameters
+   //
+   // 1st, primary vertex
+   //
+   double xpos = fXFlatSpread > 0. ? fRandomGenerator->fire(-fXFlatSpread,fXFlatSpread) : 0.;
+   double ypos = fYFlatSpread > 0. ? fRandomGenerator->fire(-fYFlatSpread,fYFlatSpread) : 0.;
+   double zpos = fZFlatSpread > 0. ? fRandomGenerator->fire(-fZFlatSpread,fZFlatSpread) : 0.;
+   HepMC::GenVertex* Vtx = new HepMC::GenVertex(HepMC::FourVector(xpos,ypos,zpos));
+
+   // loop over particles
+   //
+   int barcode = 1 ;
+   for (unsigned int ip=0; ip<fPartIDs.size(); ++ip)
+   {
+
+       double pt     = fRandomGenerator->fire(fMinPt, fMaxPt) ;
+       double eta    = fRandomGenerator->fire(fMinEta, fMaxEta) ;
+       double phi    = fRandomGenerator->fire(fMinPhi, fMaxPhi) ;
+       double charge = fRandomGenerator->fire(0, 1) ;
+       int PartID = fPartIDs[ip] ;
+       if ( charge < 0.5 )  PartID = -PartID;
+       const HepPDT::ParticleData* 
+          PData = fPDGTable->particle(HepPDT::ParticleID(abs(PartID))) ;
+       double mass   = PData->mass().value() ;
+       double theta  = 2.*atan(exp(-eta)) ;
+       double mom    = pt/sin(theta) ;
+       double px     = pt*cos(phi) ;
+       double py     = pt*sin(phi) ;
+       double pz     = mom*cos(theta) ;
+       double energy2= mom*mom + mass*mass ;
+       double energy = sqrt(energy2) ; 
+       HepMC::FourVector p(px,py,pz,energy) ;
+       HepMC::GenParticle* Part = 
+           new HepMC::GenParticle(p,PartID,1);
+       Part->suggest_barcode( barcode ) ;
+       barcode++ ;
+       Vtx->add_particle_out(Part);
+
+       if ( fAddAntiParticle )
+       {
+          HepMC::FourVector ap(-px,-py,-pz,energy) ;
+	  int APartID = -PartID ;
+	  if ( PartID == 22 || PartID == 23 )
+	  {
+	     APartID = PartID ;
+	  }	  
+	  HepMC::GenParticle* APart =
+	     new HepMC::GenParticle(ap,APartID,1);
+	  APart->suggest_barcode( barcode ) ;
+	  barcode++ ;
+	  Vtx->add_particle_out(APart) ;
+       }
+
+   }
+
+   fEvt->add_vertex(Vtx) ;
+   fEvt->set_event_number(e.id().event()) ;
+   fEvt->set_signal_process_id(20) ; 
+        
+   if ( fVerbosity > 0 )
+   {
+      fEvt->print() ;  
+   }
+
+   auto_ptr<HepMCProduct> BProduct(new HepMCProduct()) ;
+   BProduct->addHepMCData( fEvt );
+   e.put(BProduct);
+
+   auto_ptr<GenEventInfoProduct> genEventInfo(new GenEventInfoProduct(fEvt));
+   e.put(genEventInfo);
+    
+   if ( fVerbosity > 0 )
+   {
+      // for testing purpose only
+      // fEvt->print() ; // prints empty info after it's made into edm::Event
+      cout << " FlatRandomPtChargeGunProducer : Event Generation Done " << endl;
+   }
+}
+#include "FWCore/Framework/interface/MakerMacros.h"
+DEFINE_FWK_MODULE(FlatRandomPtChargeGunProducer);
